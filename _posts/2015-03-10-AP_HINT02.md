---
layout: post
title: 访问路径的HINT（中）
date: 2015-3-10
categories: oracle优化
tags: [oracle优化,oracle基础知识]
description: 优化基础。
---


今天继续介绍ORACLE数据库中访问路径的HINT，此博文为访问路径HINT系列的中篇，主要介绍INDEX_ASC、INDEX_DESC、INDEX_COMBINE、INDEX_JOIN这四个HINT，那么下面就开始吧～！

### INDEX_ASC

![index_asc](https://docs.oracle.com/cd/E11882_01/server.112/e41084/img/index_asc_hint.gif)

INDEX_ASC通知优化器对指定的表进行索引升序扫描。如果语句用了索引范围扫描，那么Oracle数据库以索引值的升序的顺序扫描索引的条目。INDEX_ASC的每个参数含义和INDEX相同(详细请看上一篇博文：访问路径的HINT（上）)。
范围扫描的默认就是以**升序**扫描索引条目的值，或以**降序**扫描一个**降序索引**。这个hint不改变索引的默认排序，因此相对INDEX不用指定更多东西,使用方法是一样的。然而，你也可以用INDEX_ASC来显示的指定升序范围扫描来改变默认扫描行为。
oracle数据库默认设置就是升序的进行索引扫描的，对于正常的索引来说，都是升序排列的，那么INDEX和INDEX_ASC在效果上是一样的。

### INDEX_DESC

![index_desc](https://docs.oracle.com/cd/E11882_01/server.112/e41084/img/index_desc_hint.gif)

INDEX_DESC将通知优化器对指定的表采用索引降序扫描的方式。如果语句中用索引范围扫描而且这个索引是升序的，那么Oracle会以索引值降序的方式扫描这个索引的条目。在分区索引中，每个分区的结果都是降序的。对于降序索引来说，这个hint实际上相当于取消了降序顺序，扫描索引条目的结果是升序的。INDEX_DESC的每个参数含义和INDEX相同。

示例：
首先创建一个降序的索引

```sql
create index EMP_EMP_ID_PK_desc on hr.employees(EMPLOYEE_ID desc);
```

以下查询，最终结果希望得到以employee_id列进行升序排列，，添加HINT使语句采用索引升序的方式扫描。（很多时候INDEX_ASC与INDEX效果等同）

```sql
SELECT /*+ INDEX_ASC(employees EMP_EMP_ID_PK_desc) */ employee_id
   FROM employees
   order by employee_id asc;

Execution Plan
----------------------------------------------------------
Plan hash value: 3786355170
 
---------------------------------------------------------------------------------------
| Id  | Operation        | Name               | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT |                    |   107 |   428 |     2  (50)| 00:00:01 |
|   1 |  SORT ORDER BY   |                    |   107 |   428 |     2  (50)| 00:00:01 |
|   2 |   INDEX FULL SCAN| EMP_EMP_ID_PK_DESC |   107 |   428 |     1   (0)| 00:00:01 |
---------------------------------------------------------------------------------------
```

如上执行计划，由于语句最后要求以升序排列，而hint中引用的的索引是降序索引，那么索引扫描之后还要再进行一次SORT ORDER BY
下面采用降序索引扫描的方式：

```sql
SELECT /*+ INDEX_desc(employees EMP_EMP_ID_PK_desc) */ employee_id
    FROM employees
     order by employee_id asc;
 
Execution Plan
----------------------------------------------------------
Plan hash value: 2878697745
 
-------------------------------------------------------------------------------------------------
| Id  | Operation                  | Name               | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT           |                    |   107 |   428 |     1   (0)| 00:00:01 |
|   1 |  INDEX FULL SCAN DESCENDING| EMP_EMP_ID_PK_DESC |   107 |   428 |     1   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------------
```

如上所见，执行计划中没有出现额外的排序，因为索引本身就是降序的。

### INDEX_COMBINE

![index_combine](https://docs.oracle.com/cd/E11882_01/server.112/e41084/img/index_combine_hint.gif)

INDEX_COMBINE通知优化器对表采用位图的访问路径的方式 。如果indexspec从INDEX_COMBINE中漏掉了，那么优化器将采用表中预估最佳成本的任意一个索引进行布尔组合。如果你指定了indexspec，那么优化器会尝试对指定索引采用布尔组合的方式。此HINT中的每个参数含义和INDEX相同。

```sql
SELECT /*+ INDEX_COMBINE(e emp_manager_ix emp_department_ix) */ *
  FROM employees e
  WHERE manager_id = 108
     OR department_id = 110;
     
Execution Plan
----------------------------------------------------------
Plan hash value: 3462844036

------------------------------------------------------------------------------------------------------
| Id  | Operation                        | Name              | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                 |                   |     6 |   414 |     3   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID     | EMPLOYEES         |     6 |   414 |     3   (0)| 00:00:01 |
|   2 |   BITMAP CONVERSION TO ROWIDS    |                   |       |       |            |          |
|   3 |    BITMAP OR                     |                   |       |       |            |          |
|   4 |     BITMAP CONVERSION FROM ROWIDS|                   |       |       |            |          |
|*  5 |      INDEX RANGE SCAN            | EMP_MANAGER_IX    |       |       |     1   (0)| 00:00:01 |
|   6 |     BITMAP CONVERSION FROM ROWIDS|                   |       |       |            |          |
|*  7 |      INDEX RANGE SCAN            | EMP_DEPARTMENT_IX |       |       |     1   (0)| 00:00:01 |
------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   5 - access("MANAGER_ID"=108)
   7 - access("DEPARTMENT_ID"=110)
```

以上执行计划中ID=4和ID=6处出现”BITMAP CONVERSION FROM ROWIDS“是因为语句中hint指定的两个索引都是b-tree索引，所以需要先进行bitmap的转换。
表eployees上的所有索引信息如下：

```sql
INDEX_NAME                     TABLE_NAME             COLUMN_NAME      COLUMN_POSITION LAST_ANAL STATUS   INDEX_TYPE
 ------------------------------ ---------------------- ---------------- --------------- --------- -------- ---------------------
 EMP_DEPARTMENT_IX              EMPLOYEES              DEPARTMENT_ID                  1 24-AUG-13 VALID    NORMAL
 EMP_EMAIL_UK                   EMPLOYEES              EMAIL                          1 24-AUG-13 VALID    NORMAL
 EMP_EMP_ID_PK                  EMPLOYEES              EMPLOYEE_ID                    1 24-AUG-13 VALID    NORMAL
 EMP_EMP_ID_PK_DESC             EMPLOYEES              SYS_NC00012$                   1 20-DEC-16 VALID    FUNCTION-BASED NORMAL
 EMP_JOB_IX                     EMPLOYEES              JOB_ID                         1 24-AUG-13 VALID    NORMAL
 EMP_MANAGER_IX                 EMPLOYEES              MANAGER_ID                     1 24-AUG-13 VALID    NORMAL
 EMP_NAME_IX                    EMPLOYEES              LAST_NAME                      1 24-AUG-13 VALID    NORMAL
 EMP_NAME_IX                    EMPLOYEES              FIRST_NAME                     2 24-AUG-13 VALID    NORMAL
```

下面建立一个和employees完全一样的表employees_01，在相应的两个列上建立bitmap索引：

```sql
create table employees_01 as select * from employees;
create bitmap index emp_manager_ix_bit on hr.employees_01(manager_id);
create bitmap index emp_department_ix_bit on hr.employees_01(department_id);

INDEX_NAME                     TABLE_NAME             COLUMN_NAME      COLUMN_POSITION LAST_ANAL STATUS   INDEX_TYPE
------------------------------ ---------------------- ---------------- --------------- --------- -------- -----------
EMP_DEPARTMENT_IX_BIT          EMPLOYEES_01           DEPARTMENT_ID                  1 20-DEC-16 VALID    BITMAP
EMP_MANAGER_IX_BIT             EMPLOYEES_01           MANAGER_ID                     1 20-DEC-16 VALID    BITMAP
```

运行下面的语句并查看执行计划：

```sql
SELECT /*+ INDEX_COMBINE(e EMP_DEPARTMENT_IX_BIT EMP_MANAGER_IX_BIT) */ *
    FROM employees_01 e
    WHERE manager_id = 108
       OR department_id = 110;
       
Execution Plan
----------------------------------------------------------
Plan hash value: 1245214328

------------------------------------------------------------------------------------------------------
| Id  | Operation                    | Name                  | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |                       |     7 |   931 |     3   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID | EMPLOYEES_01          |     7 |   931 |     3   (0)| 00:00:01 |
|   2 |   BITMAP CONVERSION TO ROWIDS|                       |       |       |            |          |
|   3 |    BITMAP OR                 |                       |       |       |            |          |
|*  4 |     BITMAP INDEX SINGLE VALUE| EMP_MANAGER_IX_BIT    |       |       |            |          |
|*  5 |     BITMAP INDEX SINGLE VALUE| EMP_DEPARTMENT_IX_BIT |       |       |            |          |
------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   4 - access("MANAGER_ID"=108)
   5 - access("DEPARTMENT_ID"=110)
```

如上，执行计划中没有出现“BITMAP CONVERSION FROM ROWIDS”。






 
### To be continued...

![小w](https://wx2.sinaimg.cn/mw1024/891ecf4fly1fr361nvrcnj207w07sad7.jpg)

###### 博文内容为小w原创，部分内容引用自官方资料，如转载请注明出处。^_^

###### 感谢关注w的小站，本小站将不定期(完全看心情～)更新分享技术知识，欢迎阅读，网址：www.itwwb.com
