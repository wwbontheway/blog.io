---
layout: post
title: 访问路径的HINT（中）
date: 2015-3-10
categories: oracle优化
tags: [oracle优化,oracle基础知识]
description: 优化基础。
---


今天继续介绍ORACLE数据库中访问路径的HINT，此博文为访问路径HINT系列的中篇，主要介绍INDEX_ASC、INDEX_DESC、INDEX_COMBINE、INDEX_JOIN这四个HINT，那么下面就开始吧～！

### INDEX_ASC

![index_asc](https://docs.oracle.com/cd/E11882_01/server.112/e41084/img/index_asc_hint.gif)

INDEX_ASC通知优化器对指定的表进行索引升序扫描。如果语句用了索引范围扫描，那么Oracle数据库以索引值的升序的顺序扫描索引的条目。INDEX_ASC的每个参数含义和INDEX相同(详细请看上一篇博文：访问路径的HINT（上）)。
范围扫描的默认就是以**升序**扫描索引条目的值，或以**降序**扫描一个**降序索引**。这个hint不改变索引的默认排序，因此相对INDEX不用指定更多东西,使用方法是一样的。然而，你也可以用INDEX_ASC来显示的指定升序范围扫描来改变默认扫描行为。
oracle数据库默认设置就是升序的进行索引扫描的，对于正常的索引来说，都是升序排列的，那么INDEX和INDEX_ASC在效果上是一样的。

### INDEX_DESC

![index_desc](https://docs.oracle.com/cd/E11882_01/server.112/e41084/img/index_desc_hint.gif)

INDEX_DESC将通知优化器对指定的表采用索引降序扫描的方式。如果语句中用索引范围扫描而且这个索引是升序的，那么Oracle会以索引值降序的方式扫描这个索引的条目。在分区索引中，每个分区的结果都是降序的。对于降序索引来说，这个hint实际上相当于取消了降序顺序，扫描索引条目的结果是升序的。INDEX_DESC的每个参数含义和INDEX相同。

示例：
首先创建一个降序的索引

```sql
create index EMP_EMP_ID_PK_desc on hr.employees(EMPLOYEE_ID desc);
```

以下查询，最终结果希望得到以employee_id列进行升序排列，，添加HINT使语句采用索引升序的方式扫描。（很多时候INDEX_ASC与INDEX效果等同）

```sql
SELECT /*+ INDEX_ASC(employees EMP_EMP_ID_PK_desc) */ employee_id
   FROM employees
   order by employee_id asc;

Execution Plan
----------------------------------------------------------
Plan hash value: 3786355170
 
---------------------------------------------------------------------------------------
| Id  | Operation        | Name               | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT |                    |   107 |   428 |     2  (50)| 00:00:01 |
|   1 |  SORT ORDER BY   |                    |   107 |   428 |     2  (50)| 00:00:01 |
|   2 |   INDEX FULL SCAN| EMP_EMP_ID_PK_DESC |   107 |   428 |     1   (0)| 00:00:01 |
---------------------------------------------------------------------------------------
```

如上执行计划，由于语句最后要求以升序排列，而hint中引用的的索引是降序索引，那么索引扫描之后还要再进行一次SORT ORDER BY
下面采用降序索引扫描的方式：

```sql
SELECT /*+ INDEX_desc(employees EMP_EMP_ID_PK_desc) */ employee_id
    FROM employees
     order by employee_id asc;
 
Execution Plan
----------------------------------------------------------
Plan hash value: 2878697745
 
-------------------------------------------------------------------------------------------------
| Id  | Operation                  | Name               | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT           |                    |   107 |   428 |     1   (0)| 00:00:01 |
|   1 |  INDEX FULL SCAN DESCENDING| EMP_EMP_ID_PK_DESC |   107 |   428 |     1   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------------
```

如上所见，执行计划中没有出现额外的排序，因为索引本身就是降序的。





 
### To be continued...

![小w](https://wx2.sinaimg.cn/mw1024/891ecf4fly1fr361nvrcnj207w07sad7.jpg)

###### 博文内容为小w原创，部分内容引用自官方资料，如转载请注明出处。^_^

###### 感谢关注w的小站，本小站将不定期(完全看心情～)更新分享技术知识，欢迎阅读，网址：www.itwwb.com
